---
title: "Bayesian Alignment Analysis (Direction + Turn Dynamics)"
output:
  html_document:
    toc: true
    toc_depth: 3
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## 0) Packages & settings

```{r}
pacman::p_load(
  brms,
  cmdstanr,
  tidyverse,
  readr,
  tidybayes,
  posterior,
  ggdist,
  ggridges,
  pheatmap,
  bayesplot
)

# Use cmdstanr if available
use_cmdstan <- cmdstanr::cmdstan_version(error_on_NA = FALSE)
if (!is.na(use_cmdstan)) {
  message("âœ… cmdstanr found: using CmdStan backend.")
  brms::set_cmdstan_path(cmdstanr::cmdstan_path())
  backend_to_use <- "cmdstanr"
} else {
  message("âš ï¸ cmdstanr not found: falling back to rstan backend.")
  backend_to_use <- "rstan"
}

options(mc.cores = parallel::detectCores())
set.seed(123)

metrics_list <- c(
  "lexical_jaccard",
  "pos_jaccard",
  "lsm_score",
  "semantic_similarity",
  "sentiment_similarity"
)
```

## 1) Load + clean + filter

```{r}
# Adjust path relative to this Rmd
df <- read_csv("../../data/outputs/merged.csv", show_col_types = FALSE)

# Keep only rows with required fields
df_clean <- df %>%
  drop_na(all_of(metrics_list), combined_topic_id, direction, turn, conv_id, combined_keywords) %>%
  mutate(
    abs_turn = abs(turn),
    direction = as.factor(direction),
    conv_id = as.factor(conv_id)
  )

# Filter A: conversation length outliers
conv_stats <- df_clean %>%
  group_by(conv_id) %>%
  summarise(n_turns = n(), .groups = "drop")

len_95 <- quantile(conv_stats$n_turns, 0.95, na.rm = TRUE)

valid_conv_ids <- conv_stats %>%
  filter(n_turns >= 2, n_turns <= len_95) %>%
  pull(conv_id)

df_filtered <- df_clean %>%
  filter(conv_id %in% valid_conv_ids)

# Filter B: turn support (by abs_turn)
turn_stats <- df_filtered %>%
  group_by(abs_turn) %>%
  summarise(n_convs = n_distinct(conv_id), .groups = "drop")

valid_turns <- turn_stats %>%
  filter(n_convs >= 200) %>%
  pull(abs_turn)

df_filtered <- df_filtered %>%
  filter(abs_turn %in% valid_turns)

cat("Final N rows:", nrow(df_filtered), "\n")
cat("N conversations:", n_distinct(df_filtered$conv_id), "\n")
cat("Turn range:", min(df_filtered$abs_turn), "to", max(df_filtered$abs_turn), "\n")
```

## 2) Topic labels (human-readable)

```{r}
topic_info <- df_filtered %>%
  group_by(combined_topic_id) %>%
  summarise(
    raw_keywords = first(combined_keywords),
    n_convs = n_distinct(conv_id),
    .groups = "drop"
  ) %>%
  mutate(
    clean_keywords = map_chr(str_split(raw_keywords, " / "),
                             ~ paste(.x[1:min(2, length(.x))], collapse = ", ")),
    topic_label = paste0(clean_keywords, " (n=", n_convs, ")"),
    topic_label = as.factor(topic_label)
  )

df_final <- df_filtered %>%
  left_join(topic_info %>% select(combined_topic_id, topic_label),
            by = "combined_topic_id")
```

## 3) Z-scoring (publication-friendly)

Two options:

- **Option A (recommended):** Z-score *within each metric* (keeps metrics comparable within themselves).
- **Option B:** Z-score within *metric Ã— direction* (if you want to focus on directional shifts).

```{r}
# Option A: within metric only
df_long <- df_final %>%
  pivot_longer(all_of(metrics_list), names_to = "metric", values_to = "value")

df_long <- df_long %>%
  group_by(metric) %>%
  mutate(z = as.numeric(scale(value))) %>%
  ungroup()

# If you prefer Option B, use this instead:
# df_long <- df_long %>%
#   group_by(metric, direction) %>%
#   mutate(z = as.numeric(scale(value))) %>%
#   ungroup()
```

## 4) Model specification (direction + turn dynamics)

**Core model** (strong default):

- Topic fingerprints, allowing topic effects to differ by direction.
- Smooth turn-position trend.
- Random intercept per conversation.

\[
z \sim 0 + \\text{topic} \\times \\text{direction} + s(|turn|) + (1 \\mid conv)
\]

```{r}
# Priors (work well with standardized z)
my_priors <- c(
  set_prior("normal(0, 1)", class = "b"),
  set_prior("exponential(1)", class = "sd"),
  set_prior("exponential(1)", class = "sigma")
)

# Publication-quality sampling settings
sampling_ctrl <- list(adapt_delta = 0.95, max_treedepth = 12)

chains_pub <- 4
iter_pub   <- 4000
warmup_pub <- 1000
```

## 5) Fit models (one per metric)

This will write:
- `bayes_draws_topic_direction.csv` (topic Ã— direction posterior draws)
- `bayes_hierarchical_stats.csv` (Conv_SD, Residual_SD, ICC-like)
- `bayes_turn_smooth_draws.csv` (smooth trend draws for plotting)

```{r}
draws_topic_dir <- list()
hierarchy_stats <- list()
smooth_draws <- list()

for (m in unique(df_long$metric)) {

  cat("\n===================================================\n")
  cat("ðŸš€ STARTING:", m, "Time:", format(Sys.time(), "%H:%M:%S"), "\n")

  d <- df_long %>% filter(metric == m)

  # Model: topic x direction + smooth(abs_turn) + (1|conv_id)
  f <- bf(z ~ 0 + topic_label * direction + s(abs_turn) + (1 | conv_id))

  fit <- brm(
    formula = f,
    data = d,
    family = gaussian(),
    prior = my_priors,
    chains = chains_pub,
    iter = iter_pub,
    warmup = warmup_pub,
    seed = 123,
    backend = backend_to_use,
    refresh = 200,
    control = sampling_ctrl
  )

  # --- A) Diagnostics quick check ---
  summ <- summary(fit)
  print(summ)

  # --- B) Hierarchical stats + ICC-like ---
  vc <- VarCorr(fit)
  conv_sd <- vc$conv_id$sd[1]
  residual_sd <- if (!is.null(vc$residual$sd[1])) vc$residual$sd[1] else NA

  icc <- (conv_sd^2) / ((conv_sd^2) + (residual_sd^2))

  hierarchy_stats[[m]] <- tibble(
    metric = m,
    conv_sd = as.numeric(conv_sd),
    residual_sd = as.numeric(residual_sd),
    icc_like = as.numeric(icc)
  )

  # --- C) Extract topic Ã— direction fixed effects draws ---
  # Extract b_* parameters safely via as_draws_df and pivot.
  dr <- as_draws_df(fit)

  b_cols <- names(dr)[str_detect(names(dr), "^b_")]

  b_long <- dr %>%
    select(all_of(b_cols), .chain, .iteration, .draw) %>%
    pivot_longer(cols = all_of(b_cols),
                 names_to = "param",
                 values_to = "value") %>%
    mutate(metric = m)

  # Keep only topic_label and interactions with direction
  b_topic_dir <- b_long %>%
    filter(str_detect(param, "^b_topic_label")) %>%
    mutate(
      topic_clean = str_remove(param, "^b_topic_label"),
      topic_clean = str_replace_all(topic_clean, ":direction", " Ã— direction")
    )

  draws_topic_dir[[m]] <- b_topic_dir

  # --- D) Smooth term draws for turn trend plotting ---
  # Conditional smooth estimates across abs_turn grid
  turn_grid <- tibble(
    abs_turn = sort(unique(d$abs_turn)),
    # dummy values for required predictors
    topic_label = levels(d$topic_label)[1],
    direction   = levels(d$direction)[1],
    conv_id     = NA
  )

  smooth_epred <- posterior_epred(fit, newdata = turn_grid, re_formula = NA)
  # smooth_epred: draws x rows

  smooth_df <- as_tibble(t(smooth_epred)) %>%
    mutate(abs_turn = turn_grid$abs_turn) %>%
    pivot_longer(cols = -abs_turn, names_to = "draw_id", values_to = "epred") %>%
    mutate(metric = m)

  smooth_draws[[m]] <- smooth_df

  # Save incremental
  write_csv(bind_rows(draws_topic_dir), "bayes_draws_topic_direction.csv")
  write_csv(bind_rows(hierarchy_stats), "bayes_hierarchical_stats.csv")
  write_csv(bind_rows(smooth_draws), "bayes_turn_smooth_draws.csv")

  rm(fit, dr, b_long, b_topic_dir, vc, smooth_epred, smooth_df)
  gc()

  cat("âœ… DONE:", m, "\n")
}

cat("\nðŸŽ‰ ALL FINISHED! Outputs saved in working directory.\n")
```

## 6) Plotting

### 6.1 Topic Ã— Direction effects with 89% intervals (recommended)

```{r fig.height=12, fig.width=12}
topic_draws <- read_csv("bayes_draws_topic_direction.csv", show_col_types = FALSE)

topic_summ <- topic_draws %>%
  group_by(metric, topic_clean) %>%
  median_qi(value, .width = 0.89) %>%
  ungroup()

topic_summ <- topic_summ %>%
  group_by(metric) %>%
  mutate(topic_clean = fct_reorder(topic_clean, value)) %>%
  ungroup()

ggplot(topic_summ, aes(x = value, y = topic_clean)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  ggdist::geom_pointinterval(size = 0.3) +
  facet_wrap(~metric, scales = "free_y") +
  labs(
    title = "Topic effects (incl. direction interactions) with 89% intervals",
    x = "Posterior effect on standardized alignment (z)",
    y = NULL
  ) +
  theme_bw() +
  theme(
    strip.text = element_text(face = "bold"),
    axis.text.y = element_text(size = 7)
  )
```

### 6.2 Conversation-level variance share (ICC-like)

```{r fig.height=5, fig.width=10}
hier <- read_csv("bayes_hierarchical_stats.csv", show_col_types = FALSE)

ggplot(hier, aes(x = reorder(metric, icc_like), y = icc_like)) +
  geom_col(alpha = 0.85) +
  coord_flip() +
  labs(
    title = "Conversation-level share of variance (ICC-like)",
    subtitle = "Higher values mean alignment is more conversation-specific (partner/context effect).",
    x = NULL,
    y = "Share of variance"
  ) +
  theme_minimal()
```

### 6.3 Turn-position dynamics (smooth trend)

```{r fig.height=6, fig.width=10}
smooth <- read_csv("bayes_turn_smooth_draws.csv", show_col_types = FALSE)

smooth_summ <- smooth %>%
  group_by(metric, abs_turn) %>%
  median_qi(epred, .width = 0.89)

ggplot(smooth_summ, aes(x = abs_turn, y = epred)) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper), alpha = 0.2) +
  geom_line() +
  facet_wrap(~metric, scales = "free_y") +
  labs(
    title = "Turn-position dynamics (posterior smooth)",
    x = "|turn| (absolute turn index)",
    y = "Expected standardized alignment (z)"
  ) +
  theme_bw()
```

### 6.4 Directional asymmetry in raw data (quick sanity check)

```{r fig.height=6, fig.width=10}
ggplot(df_long, aes(x = direction, y = z)) +
  geom_violin(trim = FALSE, alpha = 0.6) +
  facet_wrap(~metric, scales = "free_y") +
  labs(
    title = "Raw directional asymmetry (standardized within metric)",
    x = NULL,
    y = "z"
  ) +
  theme_minimal()
```

