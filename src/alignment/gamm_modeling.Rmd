---
title: "Alignment Analysis with GAMM (Frequentist)"
output:
  html_document:
    toc: true
    toc_depth: 3
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## 0) Packages

```{r}
pacman::p_load(
  tidyverse,
  readr,
  mgcv,
  gratia,
  ggh4x
)
```

## 1) Load + clean + filter

```{r}
# Adjust path relative to this Rmd
df <- read_csv("../../data/outputs/merged.csv", show_col_types = FALSE)

metrics_list <- c(
  "lexical_jaccard",
  "pos_jaccard",
  "lsm_score",
  "semantic_similarity",
  "sentiment_similarity"
)

metric_labels <- c(
  lexical_jaccard = "Lexical Alignment",
  pos_jaccard = "Syntactic Alignment",
  lsm_score = "Linguistic Style Matching",
  semantic_similarity = "Semantic Alignment",
  sentiment_similarity = "Sentiment Alignment"
)

# Keep only rows with required fields
df_clean <- df %>%
  drop_na(all_of(metrics_list), combined_topic_id, direction, turn, conv_id, combined_keywords) %>%
  mutate(
    abs_turn = abs(turn),
    direction = as.factor(direction),
    conv_id = as.factor(conv_id),
    model_family = case_when(
      is.na(model_slug) ~ "other",
      str_detect(model_slug, "^gpt-4") ~ "gpt-4",
      str_detect(model_slug, "^gpt-5") ~ "gpt-5",
      str_detect(model_slug, "^o") ~ "o",
      TRUE ~ "other"
    ),
    model_family = factor(model_family, levels = c("gpt-4", "gpt-5", "o", "other"))
  )

# Filter A: conversation length outliers
conv_stats <- df_clean %>%
  group_by(conv_id) %>%
  summarise(n_turns = n(), .groups = "drop")

len_95 <- quantile(conv_stats$n_turns, 0.95, na.rm = TRUE)

valid_conv_ids <- conv_stats %>%
  filter(n_turns >= 2, n_turns <= len_95) %>%
  pull(conv_id)

df_filtered <- df_clean %>%
  filter(conv_id %in% valid_conv_ids)

# Filter B: turn support by absolute turn index
turn_stats <- df_filtered %>%
  group_by(abs_turn) %>%
  summarise(n_convs = n_distinct(conv_id), .groups = "drop")

valid_turns <- turn_stats %>%
  filter(n_convs >= 200) %>%
  pull(abs_turn)

df_filtered <- df_filtered %>%
  filter(abs_turn %in% valid_turns)

cat("Final N rows:", nrow(df_filtered), "\n")
cat("N conversations:", n_distinct(df_filtered$conv_id), "\n")
cat("Turn range:", min(df_filtered$abs_turn), "to", max(df_filtered$abs_turn), "\n")
```

## 1b) Summary stats

```{r}
raw_conv_path <- "../../data/raw/conversations.jsonl"
raw_conv_count <- if (file.exists(raw_conv_path)) {
  length(readLines(raw_conv_path, warn = FALSE))
} else {
  NA_integer_
}

to_flag <- function(x) {
  if (is.logical(x)) {
    return(x)
  }
  vals <- tolower(as.character(x))
  vals %in% c("true", "t", "1", "yes")
}

has_tools_flag <- function(x) {
  if (is.null(x)) {
    return(FALSE)
  }
  if (is.list(x)) {
    return(length(x) > 0)
  }
  s <- str_trim(as.character(x))
  if (is.na(s) || s == "" || s == "[]" || s == "na" || s == "null") {
    return(FALSE)
  }
  TRUE
}

conv_level <- df_filtered %>%
  group_by(conv_id) %>%
  summarise(
    has_custom_instructions = any(to_flag(has_custom_instructions), na.rm = TRUE),
    custom_gpt_used = any(to_flag(custom_gpt_used), na.rm = TRUE),
    has_reasoning = any(to_flag(has_reasoning), na.rm = TRUE),
    has_tools = any(map_lgl(tools_used, has_tools_flag), na.rm = TRUE),
    model_family = first(model_family),
    .groups = "drop"
  )

turn_stats_filtered <- df_filtered %>%
  group_by(conv_id) %>%
  summarise(n_turns = n(), .groups = "drop")

convs_total <- n_distinct(df_clean$conv_id)
convs_lt2 <- conv_stats %>% filter(n_turns < 2) %>% nrow()
convs_gt95 <- conv_stats %>% filter(n_turns > len_95) %>% nrow()
convs_retained <- length(valid_conv_ids)
turns_total <- n_distinct(turn_stats$abs_turn)
turns_retained <- length(valid_turns)
turns_dropped <- turns_total - turns_retained

fmt_n <- function(x) {
  if (is.na(x)) return("NA")
  format(x, big.mark = ",", scientific = FALSE, trim = TRUE)
}

fmt_pct <- function(x) {
  if (is.na(x)) return("NA")
  sprintf("%.1f%%", 100 * x)
}

summary_stats <- tibble(
  metric = c(
    "Raw conversations (retrieved)",
    "Merged rows (raw)",
    "Merged conversations (raw)",
    "Filtered rows",
    "Filtered conversations",
    "Convs excluded (<2 turns)",
    "Convs excluded (>95th percentile length)",
    "Convs retained after length filter",
    "95th percentile length (turns)",
    "Turn positions retained (>=200 convs)",
    "Turn positions excluded (<200 convs)",
    "Median turns per conversation (filtered)",
    "Median tokens per turn (filtered)",
    "Custom instructions (% convs, filtered)",
    "Custom GPT used (% convs, filtered)",
    "Reasoning present (% convs, filtered)",
    "Tools used (% convs, filtered)",
    "Model family = gpt-4 (% convs, filtered)",
    "Model family = gpt-5 (% convs, filtered)",
    "Model family = o (% convs, filtered)",
    "Model family = other (% convs, filtered)"
  ),
  value = c(
    fmt_n(raw_conv_count),
    fmt_n(nrow(df)),
    fmt_n(n_distinct(df$conv_id)),
    fmt_n(nrow(df_filtered)),
    fmt_n(n_distinct(df_filtered$conv_id)),
    fmt_n(convs_lt2),
    fmt_n(convs_gt95),
    fmt_n(convs_retained),
    fmt_n(len_95),
    fmt_n(turns_retained),
    fmt_n(turns_dropped),
    fmt_n(median(turn_stats_filtered$n_turns, na.rm = TRUE)),
    fmt_n(median(df_filtered$n_tokens_total, na.rm = TRUE)),
    fmt_pct(mean(conv_level$has_custom_instructions, na.rm = TRUE)),
    fmt_pct(mean(conv_level$custom_gpt_used, na.rm = TRUE)),
    fmt_pct(mean(conv_level$has_reasoning, na.rm = TRUE)),
    fmt_pct(mean(conv_level$has_tools, na.rm = TRUE)),
    fmt_pct(mean(conv_level$model_family == "gpt-4", na.rm = TRUE)),
    fmt_pct(mean(conv_level$model_family == "gpt-5", na.rm = TRUE)),
    fmt_pct(mean(conv_level$model_family == "o", na.rm = TRUE)),
    fmt_pct(mean(conv_level$model_family == "other", na.rm = TRUE))
  )
)

knitr::kable(summary_stats, col.names = c("Metric", "Value"))
```

```{r}
direction_stats <- df_filtered %>%
  count(direction) %>%
  mutate(
    pct = n / sum(n),
    n = fmt_n(n),
    pct = fmt_pct(pct)
  ) %>%
  rename(Direction = direction, `Rows` = n, `Percent` = pct)

knitr::kable(direction_stats)
```

```{r}
topic_summary <- df_filtered %>%
  count(topic_label, sort = TRUE) %>%
  mutate(
    pct = n / sum(n),
    n = fmt_n(n),
    pct = fmt_pct(pct)
  ) %>%
  rename(`Topic` = topic_label, `Rows` = n, `Percent` = pct) %>%
  head(10)

knitr::kable(topic_summary)
```

## 2) Topic labels

```{r}
topic_info <- df_filtered %>%
  group_by(combined_topic_id) %>%
  summarise(
    raw_keywords = first(combined_keywords),
    n_convs = n_distinct(conv_id),
    .groups = "drop"
  ) %>%
  mutate(
    clean_keywords = map_chr(str_split(raw_keywords, " / "),
                             ~ paste(.x[1:min(2, length(.x))], collapse = ", ")),
    topic_label = paste0(clean_keywords, " (n=", n_convs, ")"),
    topic_label = as.factor(topic_label)
  )

df_final <- df_filtered %>%
  left_join(topic_info %>% dplyr::select(combined_topic_id, topic_label),
            by = "combined_topic_id")
```

## 3) Z-scoring

```{r}
df_long <- df_final %>%
  pivot_longer(all_of(metrics_list), names_to = "metric", values_to = "value")

df_long <- df_long %>%
  group_by(metric) %>%
  mutate(z = as.numeric(scale(value))) %>%
  ungroup()

if (!"model_family" %in% names(df_long)) {
  df_long <- df_long %>%
    mutate(
      model_family = case_when(
        is.na(model_slug) ~ "other",
        str_detect(model_slug, "^gpt-4") ~ "gpt-4",
        str_detect(model_slug, "^gpt-5") ~ "gpt-5",
        str_detect(model_slug, "^o") ~ "o",
        TRUE ~ "other"
      ),
      model_family = factor(model_family, levels = c("gpt-4", "gpt-5", "o", "other"))
    )
}

metric_diag <- df_long %>%
  group_by(metric) %>%
  summarise(
    n = n(),
    sd_z = sd(z, na.rm = TRUE),
    range_z = diff(range(z, na.rm = TRUE)),
    n_unique = n_distinct(z),
    cor_turn = cor(abs_turn, z, use = "complete.obs"),
    .groups = "drop"
  ) %>%
  mutate(metric_label = metric_labels[metric]) %>%
  relocate(metric_label, .after = metric)

metric_diag
```

## 4) Model specification

The GAMM mirrors the Bayesian structure, with topic-varying temporal dynamics:
- Fixed effects for topic and direction, including their interaction
- Global smooth for absolute turn index
- Topic-specific smooth deviations over turns
- Random intercept for conversation

```{r}
gamm_formula <- z ~ 0 + topic_label * direction +
  s(abs_turn, k = 10, bs = "cs") +
  s(abs_turn, topic_label, k = 8, bs = "fs") +
  s(conv_id, bs = "re")
```

## 5) Fit models (one per metric)

Outputs (under data/outputs/gamm):
- gamm_models (RDS files per metric)
- gamm_summary.csv (parametric terms)
- gamm_smooths.csv (smooth term summaries)

```{r}
outputs_dir <- "../../data/outputs/gamm"
models_dir <- file.path(outputs_dir, "gamm_models")
fig_dir <- file.path(outputs_dir, "figures")
dir.create(models_dir, showWarnings = FALSE, recursive = TRUE)
dir.create(fig_dir, showWarnings = FALSE, recursive = TRUE)

param_summaries <- list()
smooth_summaries <- list()

for (m in unique(df_long$metric)) {
  cat("\n===================================================\n")
  cat("FITTING GAMM:", m, "Time:", format(Sys.time(), "%H:%M:%S"), "\n")

  d <- df_long %>% filter(metric == m)

  fit <- bam(
    formula = gamm_formula,
    data = d,
    method = "fREML",
    discrete = TRUE,
    nthreads = max(1, parallel::detectCores() - 1)
  )

  saveRDS(fit, file = file.path(models_dir, paste0("gamm_", m, ".rds")))

  # Parametric term summary
  ptab <- summary(fit)$p.table
  if (!is.null(ptab)) {
    ptab_df <- as.data.frame(ptab)
    ptab_df$term <- rownames(ptab)
    names(ptab_df) <- c("estimate", "std_error", "t_value", "p_value", "term")
    ptab_df$metric <- m
    param_summaries[[m]] <- ptab_df
  }

  # Smooth term summary
  stab <- summary(fit)$s.table
  if (!is.null(stab)) {
    stab_df <- as.data.frame(stab)
    stab_df$term <- rownames(stab)
    stab_df$metric <- m
    smooth_summaries[[m]] <- stab_df
  }

  write_csv(bind_rows(param_summaries), file.path(outputs_dir, "gamm_summary.csv"))
  write_csv(bind_rows(smooth_summaries), file.path(outputs_dir, "gamm_smooths.csv"))

  rm(fit, ptab, stab, ptab_df, stab_df)
  gc()
}
```

## 6) Plotting

### 6.1 Direction effects (parametric terms)

```{r fig.height=6, fig.width=10}
param <- read_csv(file.path(outputs_dir, "gamm_summary.csv"), show_col_types = FALSE) %>%
  mutate(metric_label = metric_labels[metric])

if (!"estimate" %in% names(param) && "Estimate" %in% names(param)) {
  param <- param %>%
    rename(
      estimate = `Estimate`,
      std_error = `Std. Error`,
      t_value = `t value`,
      p_value = `Pr(>|t|)`
    )
}

dir_effects <- param %>%
  filter(str_detect(term, "^direction")) %>%
  filter(!str_detect(term, ":")) %>%
  mutate(
    term = str_replace(term, "^direction", ""),
    term = str_replace_all(term, "\\u2192", "->"),
    term = paste0("direction", term)
  )

p_dir_effects <- ggplot(dir_effects, aes(x = estimate, y = term, color = metric_label)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_errorbarh(
    aes(xmin = estimate - 1.96 * std_error,
        xmax = estimate + 1.96 * std_error),
    height = 0.2
  ) +
  facet_wrap(~metric_label, scales = "free_y") +
  labs(
    title = "Direction effects across metrics",
    x = "Estimate (z)",
    y = NULL
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 9))

p_dir_effects
ggsave(file.path(fig_dir, "direction_effects.png"), p_dir_effects, width = 10, height = 6, dpi = 300)
```

### 6.1b Direction effects with topic interaction dispersion

```{r fig.height=6, fig.width=10}
extract_direction <- function(term) {
  has_dir <- str_detect(term, "direction")
  dir <- str_replace(term, ".*direction", "")
  dir <- str_replace_all(dir, "[:()]", "")
  dir <- str_replace_all(dir, "\\s+", "")
  ifelse(has_dir, dir, NA_character_)
}

dir_main <- param %>%
  filter(str_detect(term, "^direction")) %>%
  filter(!str_detect(term, ":")) %>%
  mutate(
    direction = extract_direction(term),
    direction = if_else(direction == "", "direction", direction)
  )

dir_inter <- param %>%
  filter(str_detect(term, "direction")) %>%
  filter(str_detect(term, ":")) %>%
  mutate(
    direction = extract_direction(term),
    direction = if_else(direction == "", "direction", direction)
  )

p_dir_dispersion <- ggplot() +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point(
    data = dir_inter,
    aes(x = estimate, y = metric_label, color = direction),
    alpha = 0.25,
    size = 1.5,
    position = position_jitter(height = 0.1, width = 0)
  ) +
  geom_errorbarh(
    data = dir_main,
    aes(xmin = estimate - 1.96 * std_error, xmax = estimate + 1.96 * std_error, y = metric_label, color = direction),
    height = 0.15,
    size = 0.6
  ) +
  geom_point(
    data = dir_main,
    aes(x = estimate, y = metric_label, color = direction),
    size = 2.5
  ) +
  labs(
    title = "Direction effects with topic interaction dispersion",
    x = "Estimate (z)",
    y = NULL,
    color = "Direction"
  ) +
  theme_minimal()

p_dir_dispersion
ggsave(file.path(fig_dir, "direction_effects_with_dispersion.png"), p_dir_dispersion,
       width = 10, height = 6, dpi = 300)
```

### 6.1c Direction marginal means (model-based)

This version shows both directions by plotting model-based marginal means,
averaged across the observed topic/turn distribution within each model family.

```{r fig.height=6, fig.width=9}
model_files <- list.files(models_dir, pattern = "^gamm_.*\\.rds$", full.names = TRUE)

dir_pred_list <- list()

for (path in model_files) {
  metric <- sub("^gamm_(.*)\\.rds$", "\\1", basename(path))
  fit <- readRDS(path)

  d <- df_long %>% filter(metric == !!metric)

  pred <- predict(
    fit,
    newdata = d,
    se.fit = TRUE,
    type = "link",
    exclude = "s(conv_id)"
  )

  d$estimate <- as.numeric(pred$fit)
  d$std_error <- as.numeric(pred$se.fit)

  dir_pred_list[[metric]] <- d
}

dir_pred <- bind_rows(dir_pred_list) %>%
  mutate(
    direction = gsub("\\u2192", "->", as.character(direction)),
    metric_label = metric_labels[metric]
  ) %>%
  group_by(metric, metric_label, model_family, direction) %>%
  summarise(
    estimate = mean(estimate, na.rm = TRUE),
    std_error = sqrt(mean(std_error^2, na.rm = TRUE)),
    .groups = "drop"
  )

model_family_labels <- df_clean %>%
  filter(!is.na(model_slug)) %>%
  distinct(model_family, model_slug) %>%
  group_by(model_family) %>%
  summarise(
    label = paste(sort(unique(model_slug)), collapse = ", "),
    .groups = "drop"
  ) %>%
  mutate(label = paste0(as.character(model_family), " (", label, ")")) %>%
  mutate(label = stringr::str_wrap(label, width = 45))

model_family_labels <- setNames(model_family_labels$label, model_family_labels$model_family)

p_dir_means <- ggplot(dir_pred, aes(x = estimate, y = metric_label, color = direction)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point(size = 2.5, position = position_dodge(width = 0.3)) +
  geom_errorbarh(
    aes(xmin = estimate - 1.96 * std_error, xmax = estimate + 1.96 * std_error),
    height = 0.2,
    position = position_dodge(width = 0.3)
  ) +
  facet_wrap(~ model_family, labeller = as_labeller(model_family_labels)) +
  labs(
    title = "Direction marginal means (model-based)",
    x = "Estimated alignment (z)",
    y = NULL,
    color = "Direction"
  ) +
  theme_minimal() +
  theme(strip.text = element_text(size = 9))

p_dir_means
ggsave(file.path(fig_dir, "direction_marginal_means.png"), p_dir_means,
       width = 9, height = 6, dpi = 300)
```

### 6.1d Direction difference over turns (model-based)

This uses model predictions over turns and averages across topics. With the
current GAMM (no direction-specific smooth), the difference is expected to be
flat over turns, but this plot makes that explicit.

```{r fig.height=6, fig.width=10}
model_files <- list.files(models_dir, pattern = "^gamm_.*\\.rds$", full.names = TRUE)

diff_list <- list()

for (path in model_files) {
  metric <- sub("^gamm_(.*)\\.rds$", "\\1", basename(path))
  fit <- readRDS(path)

  model_data <- fit$model
  direction_levels <- levels(model_data$direction)

  turn_grid <- 1:20
  grid <- expand.grid(
    abs_turn = turn_grid,
    topic_label = levels(model_data$topic_label),
    direction = direction_levels,
    stringsAsFactors = FALSE
  )
  grid$conv_id <- model_data$conv_id[1]

  pred <- predict(
    fit,
    newdata = grid,
    se.fit = TRUE,
    type = "link",
    exclude = "s(conv_id)"
  )

  grid$estimate <- as.numeric(pred$fit)
  grid$std_error <- as.numeric(pred$se.fit)
  grid$metric <- metric

  grid_summ <- grid %>%
    group_by(metric, direction, abs_turn) %>%
    summarise(
      estimate = mean(estimate, na.rm = TRUE),
      std_error = sqrt(mean(std_error^2, na.rm = TRUE)),
      .groups = "drop"
    )

  if (length(direction_levels) >= 2) {
    d1 <- direction_levels[1]
    d2 <- direction_levels[2]
    d1_df <- grid_summ %>% filter(direction == d1)
    d2_df <- grid_summ %>% filter(direction == d2)
    diff_df <- d1_df %>%
      inner_join(d2_df, by = c("metric", "abs_turn"), suffix = c("_d1", "_d2")) %>%
      mutate(
        direction_contrast = paste0(d1, " minus ", d2),
        estimate = estimate_d1 - estimate_d2,
        std_error = sqrt(std_error_d1^2 + std_error_d2^2)
      ) %>%
      select(metric, abs_turn, direction_contrast, estimate, std_error)
    diff_list[[metric]] <- diff_df
  }
}

dir_diff <- bind_rows(diff_list) %>%
  mutate(
    direction_contrast = gsub("\\u2192", "->", as.character(direction_contrast)),
    metric_label = metric_labels[metric]
  )

p_dir_diff <- ggplot(dir_diff, aes(x = abs_turn, y = estimate)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  geom_ribbon(aes(ymin = estimate - 1.96 * std_error, ymax = estimate + 1.96 * std_error),
              alpha = 0.2) +
  geom_line() +
  facet_wrap(~ metric_label, scales = "free_y") +
  labs(
    title = "Direction difference over turns (model-based)",
    subtitle = "User→assistant minus assistant→user",
    x = "Absolute turn index",
    y = "Estimated difference (z)"
  ) +
  theme_minimal()

p_dir_diff
ggsave(file.path(fig_dir, "direction_difference_over_turns.png"), p_dir_diff,
       width = 10, height = 6, dpi = 300)
```

### 6.2 Turn-position dynamics (global smooth term)

```{r fig.height=6, fig.width=10}
smooth_df <- read_csv(file.path(outputs_dir, "gamm_smooths.csv"), show_col_types = FALSE)
smooth_df <- smooth_df %>% filter(term == "s(abs_turn)")

p_smooth_edf <- ggplot(smooth_df, aes(x = metric, y = edf)) +
  geom_col(alpha = 0.8) +
  coord_flip() +
  labs(
    title = "Turn smooth complexity (edf by metric)",
    x = NULL,
    y = "Effective degrees of freedom"
  ) +
  theme_minimal()

p_smooth_edf
ggsave(file.path(fig_dir, "turn_smooth_edf.png"), p_smooth_edf, width = 10, height = 6, dpi = 300)
```

### 6.3 Smooth curve for a single metric

```{r fig.height=5, fig.width=9}
plot_metric <- "semantic_similarity"
fit_plot <- readRDS(file.path(models_dir, paste0("gamm_", plot_metric, ".rds")))

smooth_plot <- gratia::draw(fit_plot, select = "s(abs_turn)") +
  ggtitle(paste("Turn dynamics:", plot_metric))
smooth_plot
ggsave(file.path(fig_dir, paste0("turn_dynamics_", plot_metric, ".png")),
       smooth_plot, width = 9, height = 5, dpi = 300)
```

### 6.4 Topic effects by direction (model-based predictions)

This uses model predictions to compare topic effects for each direction while
excluding the smooth and random-effect terms. It gives direction-specific topic
effects with standard errors.

```{r fig.height=12, fig.width=12}
model_files <- list.files(models_dir, pattern = "^gamm_.*\\.rds$", full.names = TRUE)

topic_pred_list <- list()

for (path in model_files) {
  metric <- sub("^gamm_(.*)\\.rds$", "\\1", basename(path))
  fit <- readRDS(path)

  model_data <- fit$model
  topic_levels <- levels(model_data$topic_label)
  direction_levels <- levels(model_data$direction)

  grid <- expand.grid(
    topic_label = topic_levels,
    direction = direction_levels,
    stringsAsFactors = FALSE
  )
  grid$abs_turn <- median(model_data$abs_turn, na.rm = TRUE)
  grid$conv_id <- model_data$conv_id[1]

  pred <- predict(
    fit,
    newdata = grid,
    se.fit = TRUE,
    type = "link",
    exclude = c("s(abs_turn)", "s(conv_id)")
  )

  grid$estimate <- as.numeric(pred$fit)
  grid$std_error <- as.numeric(pred$se.fit)
  grid$metric <- metric

  topic_pred_list[[metric]] <- grid
}

topic_pred <- bind_rows(topic_pred_list) %>%
  mutate(
    topic_label = as.character(topic_label),
    direction = gsub("\\u2192", "->", as.character(direction))
  )

top_topics <- topic_pred %>%
  group_by(metric, direction) %>%
  slice_max(order_by = abs(estimate), n = 12, with_ties = FALSE) %>%
  ungroup()

p_topic_dir <- ggplot(top_topics, aes(x = estimate, y = reorder(topic_label, estimate))) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_errorbarh(
    aes(xmin = estimate - 1.96 * std_error,
        xmax = estimate + 1.96 * std_error),
    height = 0.2
  ) +
  facet_grid(direction ~ metric, scales = "free_y") +
  labs(
    title = "Topic effects by direction (model-based)",
    x = "Estimated alignment effect (z)",
    y = NULL
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 7))

p_topic_dir
ggsave(file.path(fig_dir, "topic_effects_by_direction.png"), p_topic_dir,
       width = 12, height = 12, dpi = 300)
```

### 6.5 Turn smooths across metrics

```{r fig.height=6, fig.width=12}
smooth_list <- list()

for (path in model_files) {
  metric <- sub("^gamm_(.*)\\.rds$", "\\1", basename(path))
  fit <- readRDS(path)

  smooth_df <- gratia::smooth_estimates(fit, smooth = "s(abs_turn)")
  if (".estimate" %in% names(smooth_df)) {
    smooth_df <- smooth_df %>% rename(estimate = .estimate)
  }
  if (".se" %in% names(smooth_df)) {
    smooth_df <- smooth_df %>% rename(se = .se)
  }
  if (!"lower_ci" %in% names(smooth_df)) {
    if (".lower_ci" %in% names(smooth_df)) {
      smooth_df <- smooth_df %>% rename(lower_ci = .lower_ci)
    } else if (!is.null(smooth_df$se)) {
      smooth_df$lower_ci <- smooth_df$estimate - 1.96 * smooth_df$se
    }
  }
  if (!"upper_ci" %in% names(smooth_df)) {
    if (".upper_ci" %in% names(smooth_df)) {
      smooth_df <- smooth_df %>% rename(upper_ci = .upper_ci)
    } else if (!is.null(smooth_df$se)) {
      smooth_df$upper_ci <- smooth_df$estimate + 1.96 * smooth_df$se
    }
  }
  smooth_df$metric <- metric
  smooth_list[[metric]] <- smooth_df
}

smooth_all <- bind_rows(smooth_list) %>%
  mutate(metric_label = metric_labels[metric])

p_smooth_x_limits <- range(smooth_all$abs_turn, na.rm = TRUE)

p_smooth_all <- ggplot(smooth_all, aes(x = abs_turn, y = estimate)) +
  geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.2) +
  geom_line() +
  ggh4x::facet_wrap2(~ metric_label, scales = "fixed", axes = "all") +
  scale_x_continuous(limits = p_smooth_x_limits) +
  labs(
    title = "Turn-position dynamics across metrics",
    x = "Turn",
    y = "Smooth contribution (z)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    strip.text = element_text(size = 12, face = "bold"),
    axis.text = element_text(size = 11),
    axis.title = element_text(size = 12)
  )

p_smooth_all
ggsave(file.path(fig_dir, "turn_dynamics_all_metrics.png"), p_smooth_all,
       width = 12, height = 6, dpi = 300)
```

### 6.6 Topic-specific trajectories over turns (model-based)

These trajectories show how alignment evolves over turns for a small set of
high-frequency topics. With the topic-varying smooth in the GAMM, the curves
can differ in shape across topics, capturing topic-specific temporal dynamics.

```{r fig.height=10, fig.width=12}
top_topics_n <- 20

topic_counts <- df_final %>%
  group_by(topic_label) %>%
  summarise(n_convs = n_distinct(conv_id), .groups = "drop") %>%
  arrange(desc(n_convs))

top_topics <- topic_counts %>%
  slice_head(n = top_topics_n) %>%
  pull(topic_label)

trajectory_list <- list()

for (path in model_files) {
  metric <- sub("^gamm_(.*)\\.rds$", "\\1", basename(path))
  fit <- readRDS(path)

  model_data <- fit$model
  direction_levels <- levels(model_data$direction)

  turn_grid <- sort(unique(model_data$abs_turn))

  grid <- expand.grid(
    abs_turn = turn_grid,
    topic_label = top_topics,
    direction = direction_levels,
    stringsAsFactors = FALSE
  )
  grid$conv_id <- model_data$conv_id[1]

  pred <- predict(
    fit,
    newdata = grid,
    se.fit = TRUE,
    type = "link",
    exclude = "s(conv_id)"
  )

  grid$estimate <- as.numeric(pred$fit)
  grid$std_error <- as.numeric(pred$se.fit)
  grid$lower <- grid$estimate - 1.96 * grid$std_error
  grid$upper <- grid$estimate + 1.96 * grid$std_error
  grid$metric <- metric

  trajectory_list[[metric]] <- grid
}

traj_df <- bind_rows(trajectory_list) %>%
  mutate(
    direction = gsub("\\u2192", "->", as.character(direction)),
    metric_label = metric_labels[metric]
  )

cluster_source_path <- "../../data/outputs/bayes/bayes_topic_alignment_outputs/tables/topic_cluster_assignments.csv"
cluster_colors_path <- "../../data/outputs/bayes/bayes_topic_alignment_outputs/tables/topic_cluster_colors.csv"
cluster_colors <- NULL

cluster_df <- NULL
if (file.exists(cluster_source_path)) {
  cluster_df <- read_csv(cluster_source_path, show_col_types = FALSE) %>%
    select(topic_label, topic_cluster) %>%
    distinct() %>%
    mutate(topic_cluster = factor(topic_cluster))
  if (file.exists(cluster_colors_path)) {
    cluster_colors_df <- read_csv(cluster_colors_path, show_col_types = FALSE)
    cluster_colors <- setNames(cluster_colors_df$color, cluster_colors_df$topic_cluster)
  }
}

if (is.null(cluster_df)) {
  cluster_df <- tibble(
    topic_label = unique(traj_df$topic_label),
    topic_cluster = factor("Unclustered")
  )
  cluster_colors <- c(Unclustered = "gray60")
} else if (is.null(cluster_colors)) {
  cluster_colors <- setNames(
    c("#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e")[seq_along(unique(cluster_df$topic_cluster))],
    sort(unique(cluster_df$topic_cluster))
  )
}

traj_df <- traj_df %>%
  left_join(cluster_df, by = "topic_label") %>%
  mutate(topic_cluster = forcats::fct_explicit_na(topic_cluster, "Unclustered"))

traj_df <- traj_df %>%
  left_join(topic_counts %>% select(topic_label, n_convs), by = "topic_label")

cluster_summary <- traj_df %>%
  group_by(metric_label, direction, abs_turn, topic_cluster) %>%
  summarise(
    weight_sum = sum(n_convs, na.rm = TRUE),
    estimate = weighted.mean(estimate, w = n_convs, na.rm = TRUE),
    std_error = sqrt(sum((n_convs^2) * (std_error^2), na.rm = TRUE)) / weight_sum,
    .groups = "drop"
  ) %>%
  mutate(
    lower = estimate - 1.96 * std_error,
    upper = estimate + 1.96 * std_error
  )

cluster_label_map <- cluster_df %>%
  distinct(topic_label, topic_cluster) %>%
  group_by(topic_cluster) %>%
  summarise(
    label = paste(topic_label, collapse = ", "),
    .groups = "drop"
  ) %>%
  mutate(
    label = if_else(
      as.character(topic_cluster) == "Unclustered",
      paste0("Unclustered: ", label),
      paste0("Cluster ", topic_cluster, ": ", label)
    ),
    label = stringr::str_wrap(label, width = 60)
  )
cluster_labels <- setNames(cluster_label_map$label, cluster_label_map$topic_cluster)

p_topic_traj <- ggplot(cluster_summary, aes(x = abs_turn, y = estimate, color = topic_cluster, fill = topic_cluster)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray60", linewidth = 0.4) +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, linewidth = 0) +
  geom_line(linewidth = 0.9) +
  facet_grid(direction ~ metric_label, scales = "fixed") +
  scale_y_continuous(
    limits = range(c(cluster_summary$lower, cluster_summary$upper), na.rm = TRUE)
  ) +
  labs(
    title = "Topic cluster trajectories over turns (model-based, weighted)",
    x = "Turn",
    y = "Estimated alignment (z)",
    color = "Topic cluster",
    fill = "Topic cluster"
  ) +
  coord_cartesian(clip = "off") +
  scale_color_manual(values = cluster_colors, labels = cluster_labels, drop = FALSE) +
  scale_fill_manual(values = cluster_colors, labels = cluster_labels, drop = FALSE) +
  guides(color = guide_legend(ncol = 4), fill = guide_legend(ncol = 4)) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 9),
    plot.title = element_text(size = 15, face = "bold"),
    strip.text = element_text(size = 11, face = "bold"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.margin = margin(5.5, 5.5, 5.5, 20)
  )

p_topic_traj
ggsave(file.path(fig_dir, "topic_trajectories_over_turns.png"), p_topic_traj,
       width = 12.5, height = 10, dpi = 300)
```

### 6.7 Topic-by-turn heatmap (model-based)

```{r fig.height=10, fig.width=12}
top_topics_n <- 20

topic_counts <- df_final %>%
  group_by(topic_label) %>%
  summarise(n_convs = n_distinct(conv_id), .groups = "drop") %>%
  arrange(desc(n_convs))

top_topics <- topic_counts %>%
  slice_head(n = top_topics_n) %>%
  pull(topic_label)

heat_list <- list()

for (path in model_files) {
  metric <- sub("^gamm_(.*)\\.rds$", "\\1", basename(path))
  fit <- readRDS(path)
  model_data <- fit$model

  direction_levels <- levels(model_data$direction)
  turn_grid <- sort(unique(model_data$abs_turn))

  grid <- expand.grid(
    abs_turn = turn_grid,
    topic_label = top_topics,
    direction = direction_levels,
    stringsAsFactors = FALSE
  )
  grid$conv_id <- model_data$conv_id[1]

  pred <- predict(
    fit,
    newdata = grid,
    se.fit = FALSE,
    type = "link",
    exclude = "s(conv_id)"
  )

  grid$estimate <- as.numeric(pred)
  grid$metric <- metric

  grid_mean <- grid %>%
    group_by(metric, topic_label, abs_turn) %>%
    summarise(estimate = mean(estimate, na.rm = TRUE), .groups = "drop")

  heat_list[[metric]] <- grid_mean
}

heat_df <- bind_rows(heat_list)

topic_order <- heat_df %>%
  filter(abs_turn %in% 1:3) %>%
  group_by(topic_label) %>%
  summarise(early_mean = mean(estimate, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(early_mean)) %>%
  pull(topic_label)

heat_df$topic_label <- factor(heat_df$topic_label, levels = topic_order)

p_heat <- ggplot(heat_df, aes(x = abs_turn, y = topic_label, fill = estimate)) +
  geom_tile() +
  scale_fill_viridis_c() +
  facet_wrap(~ metric, scales = "free_y") +
  labs(
    title = "Topic-by-turn heatmap (model-based)",
    x = "Absolute turn index",
    y = "Topic",
    fill = "Estimated alignment (z)"
  ) +
  coord_cartesian(clip = "off") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 7),
    plot.margin = margin(5.5, 5.5, 5.5, 30)
  )

p_heat
ggsave(file.path(fig_dir, "topic_turn_heatmap.png"), p_heat,
       width = 12.5, height = 10, dpi = 300)
```
