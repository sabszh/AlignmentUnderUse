---
title: "Bayesian Alignment Analysis (Direction + Turn Dynamics)"
output:
  html_document:
    toc: true
    toc_depth: 3
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## 0) Packages & settings

```{r}
pacman::p_load(
  tidyverse,
  readr,
  pheatmap
)

metrics_list <- c(
  "lexical_jaccard",
  "pos_jaccard",
  "lsm_score",
  "semantic_similarity",
  "sentiment_similarity"
)
```

## 1) Load + clean + filter

```{r}
# Adjust path relative to this Rmd
df <- read_csv("../../data/outputs/merged.csv", show_col_types = FALSE)

# Keep only rows with required fields
df_clean <- df %>%
  drop_na(all_of(metrics_list), combined_topic_id, direction, turn, conv_id, combined_keywords) %>%
  mutate(
    abs_turn = abs(turn),
    direction = as.factor(direction),
    conv_id = as.factor(conv_id)
  )

# Filter A: conversation length outliers
conv_stats <- df_clean %>%
  group_by(conv_id) %>%
  summarise(n_turns = n(), .groups = "drop")

len_95 <- quantile(conv_stats$n_turns, 0.95, na.rm = TRUE)

valid_conv_ids <- conv_stats %>%
  filter(n_turns >= 2, n_turns <= len_95) %>%
  pull(conv_id)

df_filtered <- df_clean %>%
  filter(conv_id %in% valid_conv_ids)

# Filter B: turn support (by abs_turn)
turn_stats <- df_filtered %>%
  group_by(abs_turn) %>%
  summarise(n_convs = n_distinct(conv_id), .groups = "drop")

valid_turns <- turn_stats %>%
  filter(n_convs >= 200) %>%
  pull(abs_turn)

df_filtered <- df_filtered %>%
  filter(abs_turn %in% valid_turns)

cat("Final N rows:", nrow(df_filtered), "\n")
cat("N conversations:", n_distinct(df_filtered$conv_id), "\n")
cat("Turn range:", min(df_filtered$abs_turn), "to", max(df_filtered$abs_turn), "\n")
```

## 2) Topic labels

```{r}
topic_info <- df_filtered %>%
  group_by(combined_topic_id) %>%
  summarise(
    raw_keywords = first(combined_keywords),
    n_convs = n_distinct(conv_id),
    .groups = "drop"
  ) %>%
  mutate(
    clean_keywords = map_chr(str_split(raw_keywords, " / "),
                             ~ paste(.x[1:min(2, length(.x))], collapse = ", ")),
    topic_label = paste0(clean_keywords, " (n=", n_convs, ")"),
    topic_label = as.factor(topic_label)
  )

df_final <- df_filtered %>%
  left_join(topic_info %>% select(combined_topic_id, topic_label),
            by = "combined_topic_id")
```

## 3) Z-scoring
```{r}
df_long <- df_final %>%
  pivot_longer(all_of(metrics_list), names_to = "metric", values_to = "value")

df_long <- df_long %>%
  group_by(metric) %>%
  mutate(z = as.numeric(scale(value))) %>%
  ungroup()
```

## 4) Fit LMER models by metric
This section fits one mixed-effects model per metric with:
- Fixed effects for topic, direction, and their interaction
- A spline over absolute turn index to model non-linear turn dynamics
- A random intercept for conversation to absorb repeated-measures structure

```{r}
library(lme4)
library(splines)

lmer_fits <- list()
timings <- tibble()

for (m in unique(df_long$metric)) {

  cat("\n==============================\n")
  cat("FITTING LMER FOR:", m, "\n")
  cat("Start:", format(Sys.time(), "%H:%M:%S"), "\n")

  t_start <- Sys.time()

  d <- df_long %>% filter(metric == m)

  fit <- lmer(
    z ~ 0 + topic_label * direction +
      ns(abs_turn, df = 6) +
      (1 | conv_id),
    data = d,
    REML = TRUE,
    control = lmerControl(
      optimizer = "bobyqa",
      optCtrl = list(maxfun = 1e5)
    )
  )

  t_end <- Sys.time()

  cat("Finished:", format(t_end, "%H:%M:%S"),
      "Elapsed:",
      round(difftime(t_end, t_start, units = "mins"), 2), "min\n")

  print(summary(fit))

  lmer_fits[[m]] <- fit

  timings <- bind_rows(
    timings,
    tibble(
      metric = m,
      start = t_start,
      end = t_end,
      elapsed_min = as.numeric(difftime(t_end, t_start, units = "mins"))
    )
  )
}

timings


```
## 5) Turn-dynamics plots
These plots show predicted alignment by absolute turn index and direction for each metric,
with fixed effects only and confidence bands.
```{r}
pacman::p_load(ggeffects,patchwork)

plot_list <- list()

for (m in names(lmer_fits)) {

  m_fit <- lmer_fits[[m]]

  preds <- ggpredict(
    m_fit,
    terms = c("abs_turn [all]", "direction"),
    type = "fixed"
  )

  preds$metric <- m

  p <- ggplot(preds, aes(x = x, y = predicted, color = group)) +
    geom_line(linewidth = 1) +
    geom_ribbon(
      aes(ymin = conf.low, ymax = conf.high, fill = group),
      alpha = 0.2,
      color = NA
    ) +
    labs(
      title = m,
      x = "|Turn|",
      y = "Predicted alignment (z)",
      color = "Direction",
      fill = "Direction"
    ) +
    theme_minimal()

  plot_list[[m]] <- p
}

wrap_plots(plot_list, ncol = 2)

```
## 6) Direction effect summary
This plot isolates the global fixed effect of direction for each metric.
It visualizes the estimate with a 95% Wald confidence interval.
```{r}
pacman::p_load(broom.mixed)

dir_effects <- map_dfr(
  lmer_fits,
  ~ tidy(.x, effects = "fixed") %>%
    filter(term == "directionuser→assistant"),
  .id = "metric"
)

ggplot(dir_effects, aes(x = estimate, y = metric)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  geom_point(size = 3) +
  geom_errorbarh(
    aes(xmin = estimate - 1.96 * std.error,
        xmax = estimate + 1.96 * std.error),
    height = 0.2
  ) +
  labs(
    x = "Assistant – User alignment (z)",
    y = NULL,
    title = "Global direction effect across alignment metrics"
  ) +
  theme_minimal()

```

## 7) Topic-by-direction effects for semantic alignment
The heatmap summarizes topic-specific interaction terms for semantic alignment.
Positive values indicate stronger alignment for user-to-assistant direction within that topic.
```{r}
sem_terms <- tidy(lmer_fits$semantic_similarity, effects = "fixed") %>%
  filter(str_detect(term, ":directionuser→assistant")) %>%
  mutate(
    topic = str_remove(term, ":directionuser→assistant"),
    topic = str_remove(topic, "topic_label")
  )

mat <- sem_terms %>%
  select(topic, estimate) %>%
  column_to_rownames("topic") %>%
  as.matrix()

pheatmap::pheatmap(
  mat,
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  color = colorRampPalette(c("blue", "white", "red"))(100),
  main = "Assistant semantic over-alignment by topic"
)

```
## 8) Lexical vs semantic coupling
These sections examine how lexical and semantic alignment co-vary overall
and within conversations, including a partial correlation controlling for turn index.
```{r}
df_pair <- df_long %>%
  filter(metric %in% c("lexical_jaccard", "semantic_similarity")) %>%
  select(conv_id, turn, abs_turn, direction, metric, z) %>%
  pivot_wider(names_from = metric, values_from = z)

cor(df_pair$lexical_jaccard, df_pair$semantic_similarity, use = "complete.obs")

```

```{r}
ggplot(df_pair, aes(x = lexical_jaccard, y = semantic_similarity)) +
  geom_point(alpha = 0.05) +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  labs(
    x = "Lexical alignment (z)",
    y = "Semantic alignment (z)",
    title = "Raw correlation between lexical and semantic alignment"
  ) +
  theme_minimal()

```
```{r}
pacman::p_load(ppcor)

pcor.test(
  df_pair$lexical_jaccard,
  df_pair$semantic_similarity,
  df_pair$abs_turn
)

```
```{r}
within_corr <- df_pair %>%
  group_by(conv_id) %>%
  summarise(
    r = cor(lexical_jaccard, semantic_similarity, use = "complete.obs"),
    n = n(),
    .groups = "drop"
  ) %>%
  filter(n >= 5)

```

```{r}
ggplot(within_corr, aes(x = r)) +
  geom_histogram(bins = 40, fill = "grey70", color = "white") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    x = "Within-conversation correlation (r)",
    y = "Number of conversations",
    title = "Within-conversation lexical–semantic alignment coupling"
  ) +
  theme_minimal()

```

